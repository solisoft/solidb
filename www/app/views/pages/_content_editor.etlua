<!-- Content Editor - Server-side rendered with HTMX -->
<div id="content-editor" class="space-y-1 relative"
     ondragover="handleEditorDragOver(event)"
     ondragleave="handleEditorDragLeave(event)"
     ondrop="handleEditorDrop(event)">

  <!-- Drop indicator -->
  <div id="drop-indicator" class="hidden h-1 bg-primary rounded-full mx-4 transition-all"></div>

  <!-- Blocks Container (Sortable) -->
  <div id="blocks-container" class="space-y-1">
    <% for _, block in ipairs(blocks or {}) do %>
      <%- partial("pages/block", { block = block, page_key = page._key, editing = false }) %>
    <% end %>
  </div>

  <!-- Add Block Button -->
  <div class="relative pt-4">
    <button onclick="toggleAddBlockMenu()" id="add-block-btn" class="text-text-muted/50 hover:text-primary transition-colors flex items-center gap-2 text-sm">
      <i class="fas fa-plus"></i>
      <span>Add block</span>
    </button>

    <div id="add-block-menu" class="hidden absolute left-0 mt-2 bg-bg-card border border-white/10 rounded-xl shadow-xl z-20 p-2 flex gap-1">
      <button hx-post="/pages/<%= page._key %>/blocks" hx-vals='{"type":"header"}' hx-target="#blocks-container" hx-swap="beforeend" onclick="toggleAddBlockMenu()" class="p-2 rounded hover:bg-white/5" title="Header"><i class="fas fa-heading text-primary"></i></button>
      <button hx-post="/pages/<%= page._key %>/blocks" hx-vals='{"type":"paragraph"}' hx-target="#blocks-container" hx-swap="beforeend" onclick="toggleAddBlockMenu()" class="p-2 rounded hover:bg-white/5" title="Paragraph"><i class="fas fa-paragraph text-primary"></i></button>
      <button hx-post="/pages/<%= page._key %>/blocks" hx-vals='{"type":"code"}' hx-target="#blocks-container" hx-swap="beforeend" onclick="toggleAddBlockMenu()" class="p-2 rounded hover:bg-white/5" title="Code"><i class="fas fa-code text-primary"></i></button>
      <button hx-post="/pages/<%= page._key %>/blocks" hx-vals='{"type":"table"}' hx-target="#blocks-container" hx-swap="beforeend" onclick="toggleAddBlockMenu()" class="p-2 rounded hover:bg-white/5" title="Table"><i class="fas fa-table text-primary"></i></button>
      <button hx-post="/pages/<%= page._key %>/blocks" hx-vals='{"type":"image"}' hx-target="#blocks-container" hx-swap="beforeend" onclick="toggleAddBlockMenu()" class="p-2 rounded hover:bg-white/5" title="Image"><i class="fas fa-image text-primary"></i></button>
      <button hx-post="/pages/<%= page._key %>/blocks" hx-vals='{"type":"file"}' hx-target="#blocks-container" hx-swap="beforeend" onclick="toggleAddBlockMenu()" class="p-2 rounded hover:bg-white/5" title="File"><i class="fas fa-file text-primary"></i></button>
      <button hx-post="/pages/<%= page._key %>/blocks" hx-vals='{"type":"ai"}' hx-target="#blocks-container" hx-swap="beforeend" onclick="toggleAddBlockMenu()" class="p-2 rounded hover:bg-white/5" title="AI Content"><i class="fas fa-wand-magic-sparkles text-purple-400"></i></button>
    </div>
  </div>

</div>

<script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
<script>
  // pageKey is defined in show.etlua
  let blockData = {}; // Cache for block data

  // Initialize blocks data from server
  <% for _, block in ipairs(blocks or {}) do %>
  blockData['<%= block.id %>'] = <%- EncodeJson(block) %>;
  <% end %>

  // Initialize Sortable
  document.addEventListener('DOMContentLoaded', function() {
    initSortable();
    highlightCode();
    // Initialize AI provider selects with last used value
    document.querySelectorAll('[id^="ai-provider-"]').forEach(select => {
      select.value = getLastAIProvider();
    });
  });

  // Re-init after HTMX swaps
  document.body.addEventListener('htmx:afterSwap', function(e) {
    if (e.detail.target.id === 'blocks-container' || e.detail.target.closest('#blocks-container')) {
      highlightCode();
    }
  });

  function initSortable() {
    const container = document.getElementById('blocks-container');
    if (!container) return;
    new Sortable(container, {
      animation: 150,
      handle: '.drag-handle',
      ghostClass: 'opacity-50',
      onEnd: function(evt) {
        saveBlockOrder();
      }
    });
  }

  function highlightCode() {
    document.querySelectorAll('pre code').forEach(el => {
      if (!el.classList.contains('hljs')) {
        hljs.highlightElement(el);
      }
    });
  }

  async function saveBlockOrder() {
    const container = document.getElementById('blocks-container');
    const order = [];
    container.querySelectorAll('[data-block-id]').forEach(el => {
      order.push(el.getAttribute('data-block-id'));
    });
    await fetch(`/pages/${pageKey}/blocks/reorder`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ order })
    });
  }

  // Toggle menus
  function toggleAddBlockMenu() {
    document.getElementById('add-block-menu').classList.toggle('hidden');
  }

  function toggleInsertMenu(btn) {
    const menu = btn.nextElementSibling;
    document.querySelectorAll('.insert-menu').forEach(m => {
      if (m !== menu) m.classList.add('hidden');
    });
    menu.classList.toggle('hidden');
  }

  // Close menus when clicking outside
  document.addEventListener('click', function(e) {
    if (!e.target.closest('#add-block-btn') && !e.target.closest('#add-block-menu')) {
      document.getElementById('add-block-menu')?.classList.add('hidden');
    }
    if (!e.target.closest('.insert-menu') && !e.target.closest('[onclick*="toggleInsertMenu"]')) {
      document.querySelectorAll('.insert-menu').forEach(m => m.classList.add('hidden'));
    }
  });

  // Track blocks in edit mode
  let editingBlocks = new Set();

  // Handle focusout to save when leaving the editing block
  document.getElementById('content-editor').addEventListener('focusout', function(e) {
    // Delay to allow focus to move to new element
    setTimeout(() => {
      const editingBlock = e.target.closest('[data-editing-block]');
      if (!editingBlock) return;

      const blockId = editingBlock.getAttribute('data-editing-block');
      if (!blockId || !editingBlocks.has(blockId)) return;

      // Check if focus moved outside this editing block
      const activeEl = document.activeElement;
      const stillInBlock = activeEl && editingBlock.contains(activeEl);

      if (!stillInBlock) {
        // Save and exit
        saveBlock(blockId).then(() => exitEditMode(blockId));
      }
    }, 100);
  });

  // Edit mode
  function enterEditMode(contentEl, blockId) {
    // Don't re-enter edit mode if already editing
    if (editingBlocks.has(blockId)) return;

    const blockEl = document.querySelector(`[data-block-id="${blockId}"]`);
    if (!blockEl) return;

    editingBlocks.add(blockId);

    // Fetch block in edit mode
    htmx.ajax('GET', `/pages/${pageKey}/blocks/${blockId}/edit`, {
      target: blockEl,
      swap: 'outerHTML'
    });
  }

  function exitEditMode(blockId) {
    const blockEl = document.querySelector(`[data-block-id="${blockId}"]`);
    if (!blockEl) return;

    editingBlocks.delete(blockId);

    // Fetch block in view mode
    htmx.ajax('GET', `/pages/${pageKey}/blocks/${blockId}`, {
      target: blockEl,
      swap: 'outerHTML'
    }).then(() => highlightCode());
  }

  // Update block fields
  async function updateBlockField(blockId, field, value) {
    if (!blockData[blockId]) blockData[blockId] = { id: blockId };
    blockData[blockId][field] = value;
  }

  async function saveBlock(blockId) {
    const data = blockData[blockId];
    if (!data) return;

    await fetch(`/pages/${pageKey}/blocks/${blockId}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(data)
    });
  }

  // Header specific
  async function saveHeaderAndExit(blockId, content) {
    updateBlockField(blockId, 'content', content);
    await saveBlock(blockId);
    exitEditMode(blockId);
  }

  // Paragraph specific
  function saveParagraphContent(blockId) {
    const editor = document.getElementById('editor-' + blockId);
    if (editor) {
      updateBlockField(blockId, 'content', editor.innerHTML);
      saveBlock(blockId);
    }
  }

  async function saveParagraphAndExit(blockId) {
    const editor = document.getElementById('editor-' + blockId);
    if (editor) {
      updateBlockField(blockId, 'content', editor.innerHTML);
      await saveBlock(blockId);
    }
    exitEditMode(blockId);
  }

  // Code specific
  async function saveCodeAndExit(blockId) {
    const editor = document.getElementById('code-editor-' + blockId);
    if (editor) {
      updateBlockField(blockId, 'content', editor.value);
      await saveBlock(blockId);
    }
    exitEditMode(blockId);
  }

  // Table specific
  function updateTableCell(blockId, rowIdx, colIdx, value) {
    if (!blockData[blockId]) blockData[blockId] = { id: blockId, data: [] };
    if (!blockData[blockId].data) blockData[blockId].data = [];
    if (!blockData[blockId].data[rowIdx]) blockData[blockId].data[rowIdx] = [];
    blockData[blockId].data[rowIdx][colIdx] = value;
  }

  async function addTableRow(blockId) {
    const data = blockData[blockId];
    if (!data || !data.data) return;
    const cols = data.data[0]?.length || 2;
    data.data.push(new Array(cols).fill(''));
    await saveBlock(blockId);
    // Refresh block
    htmx.ajax('GET', `/pages/${pageKey}/blocks/${blockId}/edit`, {
      target: `[data-block-id="${blockId}"]`,
      swap: 'outerHTML'
    });
  }

  async function addTableCol(blockId) {
    const data = blockData[blockId];
    if (!data || !data.data) return;
    for (let row of data.data) row.push('');
    if (!data.columnWidths) data.columnWidths = data.data[0].map(() => 150);
    data.columnWidths.push(150);
    await saveBlock(blockId);
    // Refresh block
    htmx.ajax('GET', `/pages/${pageKey}/blocks/${blockId}/edit`, {
      target: `[data-block-id="${blockId}"]`,
      swap: 'outerHTML'
    });
  }

  // Table resize
  let resizing = null;

  function startTableResize(e, blockId, colIndex) {
    e.preventDefault();
    const data = blockData[blockId];
    if (!data || !data.columnWidths) return;

    resizing = {
      blockId,
      colIndex,
      startX: e.clientX,
      startWidth: data.columnWidths[colIndex]
    };

    document.addEventListener('mousemove', doTableResize);
    document.addEventListener('mouseup', stopTableResize);
  }

  function doTableResize(e) {
    if (!resizing) return;
    const delta = e.clientX - resizing.startX;
    const newWidth = Math.max(50, resizing.startWidth + delta);
    blockData[resizing.blockId].columnWidths[resizing.colIndex] = newWidth;

    // Update DOM
    const table = document.querySelector(`[data-block-id="${resizing.blockId}"] table`);
    if (table) {
      const cols = table.querySelectorAll('col');
      if (cols[resizing.colIndex]) {
        cols[resizing.colIndex].style.width = newWidth + 'px';
      }
      // Update table width
      const totalWidth = blockData[resizing.blockId].columnWidths.reduce((a, b) => a + b, 0);
      table.style.width = totalWidth + 'px';
    }
  }

  function stopTableResize() {
    if (resizing) {
      saveBlock(resizing.blockId);
      resizing = null;
    }
    document.removeEventListener('mousemove', doTableResize);
    document.removeEventListener('mouseup', stopTableResize);
  }

  // Global drag & drop for files
  let dropTargetBlockId = null;

  function handleEditorDragOver(e) {
    // Only handle file drops
    if (!e.dataTransfer.types.includes('Files')) return;

    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';

    const indicator = document.getElementById('drop-indicator');
    const container = document.getElementById('blocks-container');
    const blocks = container.querySelectorAll('[data-block-id]');

    // Find the closest block to insert after
    let insertAfterBlock = null;
    let insertY = container.getBoundingClientRect().bottom;

    for (const block of blocks) {
      const rect = block.getBoundingClientRect();
      const blockMiddle = rect.top + rect.height / 2;

      if (e.clientY < blockMiddle) {
        insertY = rect.top;
        break;
      }
      insertAfterBlock = block.getAttribute('data-block-id');
      insertY = rect.bottom;
    }

    dropTargetBlockId = insertAfterBlock;

    // Show indicator
    indicator.classList.remove('hidden');
    indicator.style.position = 'absolute';
    indicator.style.left = '0';
    indicator.style.right = '0';
    indicator.style.top = (insertY - container.parentElement.getBoundingClientRect().top) + 'px';
  }

  function handleEditorDragLeave(e) {
    // Only hide if leaving the editor entirely
    if (e.relatedTarget && e.currentTarget.contains(e.relatedTarget)) return;

    document.getElementById('drop-indicator').classList.add('hidden');
    dropTargetBlockId = null;
  }

  async function handleEditorDrop(e) {
    const indicator = document.getElementById('drop-indicator');
    indicator.classList.add('hidden');

    // Only handle file drops
    if (!e.dataTransfer.types.includes('Files')) return;

    e.preventDefault();

    const file = e.dataTransfer.files[0];
    if (!file) return;

    // Determine block type
    const isImage = file.type.startsWith('image/');
    const blockType = isImage ? 'image' : 'file';

    // Create the block
    const body = { type: blockType };
    if (dropTargetBlockId) {
      body.after_id = dropTargetBlockId;
    }

    const resp = await fetch(`/pages/${pageKey}/blocks`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(body)
    });

    const html = await resp.text();

    // Insert the new block
    const container = document.getElementById('blocks-container');
    if (dropTargetBlockId) {
      const afterBlock = container.querySelector(`[data-block-id="${dropTargetBlockId}"]`);
      if (afterBlock) {
        afterBlock.insertAdjacentHTML('afterend', html);
      } else {
        container.insertAdjacentHTML('beforeend', html);
      }
    } else {
      container.insertAdjacentHTML('afterbegin', html);
    }

    // Get the new block ID from the inserted HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = html;
    const newBlockId = tempDiv.querySelector('[data-block-id]')?.getAttribute('data-block-id');

    if (newBlockId) {
      // Upload the file and update the block
      await uploadFile(file, newBlockId, blockType);
    }

    dropTargetBlockId = null;
  }

  // Image/File upload
  async function handleImageDrop(e, blockId) {
    e.preventDefault();
    e.currentTarget.classList.remove('border-primary');
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) {
      await uploadFile(file, blockId, 'image');
    }
  }

  async function handleImageSelect(e, blockId) {
    const file = e.target.files[0];
    if (file) {
      await uploadFile(file, blockId, 'image');
    }
  }

  async function handleFileDrop(e, blockId) {
    e.preventDefault();
    e.currentTarget.classList.remove('border-primary');
    const file = e.dataTransfer.files[0];
    if (file) {
      await uploadFile(file, blockId, 'file');
    }
  }

  async function handleFileSelect(e, blockId) {
    const file = e.target.files[0];
    if (file) {
      await uploadFile(file, blockId, 'file');
    }
  }

  async function uploadFile(file, blockId, type) {
    const formData = new FormData();
    formData.append('file', file);

    const resp = await fetch('/pages/upload_file', { method: 'POST', body: formData });
    const data = await resp.json();

    if (data.url) {
      if (!blockData[blockId]) blockData[blockId] = { id: blockId };
      blockData[blockId].url = data.url;
      if (type === 'file') {
        blockData[blockId].filename = data.filename || file.name;
      }
      await saveBlock(blockId);

      // Refresh block
      htmx.ajax('GET', `/pages/${pageKey}/blocks/${blockId}`, {
        target: `[data-block-id="${blockId}"]`,
        swap: 'outerHTML'
      });
    }
  }

  // AI Content Generation
  const AI_PROVIDER_KEY = 'solidb_ai_provider';

  function getLastAIProvider() {
    return localStorage.getItem(AI_PROVIDER_KEY) || 'default';
  }

  function setLastAIProvider(provider) {
    localStorage.setItem(AI_PROVIDER_KEY, provider);
  }

  // Initialize AI provider dropdowns with last used value
  function initAIProviderSelect(blockId) {
    const providerEl = document.getElementById('ai-provider-' + blockId);
    if (providerEl) {
      providerEl.value = getLastAIProvider();
    }
  }

  // Auto-init when AI blocks are added via HTMX
  document.body.addEventListener('htmx:afterSwap', function(e) {
    const aiProviderSelects = e.detail.target.querySelectorAll('[id^="ai-provider-"]');
    aiProviderSelects.forEach(select => {
      select.value = getLastAIProvider();
    });
  });

  async function generateAIContent(blockId) {
    const promptEl = document.getElementById('ai-prompt-' + blockId);
    const providerEl = document.getElementById('ai-provider-' + blockId);
    const loadingEl = document.getElementById('ai-loading-' + blockId);
    const errorEl = document.getElementById('ai-error-' + blockId);
    const btnEl = document.getElementById('ai-generate-btn-' + blockId);

    const prompt = promptEl?.value?.trim();
    const provider = providerEl?.value || 'default';

    // Save provider choice for next time
    setLastAIProvider(provider);

    if (!prompt) {
      const errMsg = errorEl?.querySelector('.error-message');
      if (errMsg) errMsg.textContent = 'Please enter a prompt';
      errorEl?.classList.remove('hidden');
      return;
    }

    // Show loading state
    loadingEl?.classList.remove('hidden');
    errorEl?.classList.add('hidden');
    if (btnEl) btnEl.disabled = true;

    try {
      const resp = await fetch(`/pages/${pageKey}/blocks/${blockId}/generate`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ prompt, provider })
      });

      const data = await resp.json();

      if (!resp.ok) {
        throw new Error(data.error || 'Failed to generate content');
      }

      if (data.success && data.created_blocks) {
        // Remove the AI block from DOM
        const aiBlock = document.querySelector(`[data-block-id="${blockId}"]`);

        // Fetch and insert each created block
        const container = document.getElementById('blocks-container');
        let insertAfter = aiBlock;

        for (const block of data.created_blocks) {
          // Fetch the rendered block HTML
          const blockResp = await fetch(`/pages/${pageKey}/blocks/${block.id}`);
          const blockHtml = await blockResp.text();

          // Insert after the previous element
          if (insertAfter) {
            insertAfter.insertAdjacentHTML('afterend', blockHtml);
            insertAfter = insertAfter.nextElementSibling;
          } else {
            container.insertAdjacentHTML('beforeend', blockHtml);
            insertAfter = container.lastElementChild;
          }

          // Update blockData cache
          blockData[block.id] = block;
        }

        // Remove the AI block
        aiBlock?.remove();

        // Re-highlight any code blocks
        highlightCode();
      }

    } catch (err) {
      const errMsg = errorEl?.querySelector('.error-message');
      if (errMsg) errMsg.textContent = err.message;
      errorEl?.classList.remove('hidden');
      loadingEl?.classList.add('hidden');
      if (btnEl) btnEl.disabled = false;
    }
  }
</script>
